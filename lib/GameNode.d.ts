import { DomNode, SkyNode } from "@hanul/skynode";
import Area from "./area/Area";
import Delay from "./delay/Delay";
import Interval from "./delay/Interval";
export interface GameNodeOptions {
    x?: number;
    y?: number;
    centerX?: number;
    centerY?: number;
    scaleX?: number;
    scaleY?: number;
    angle?: number;
    speedX?: number;
    toX?: number;
    speedY?: number;
    toY?: number;
    scalingSpeedX?: number;
    toScaleX?: number;
    scalingSpeedY?: number;
    toScaleY?: number;
    rotationSpeed?: number;
    toAngle?: number;
    fadingSpeed?: number;
    toAlpha?: number;
    accelX?: number;
    minSpeedX?: number;
    maxSpeedX?: number;
    accelY?: number;
    minSpeedY?: number;
    maxSpeedY?: number;
    scalingAccelX?: number;
    minScalingSpeedX?: number;
    maxScalingSpeedX?: number;
    scalingAccelY?: number;
    minScalingSpeedY?: number;
    maxScalingSpeedY?: number;
    rotationAccel?: number;
    minRotationSpeed?: number;
    maxRotationSpeed?: number;
    fadingAccel?: number;
    minFadingSpeed?: number;
    maxFadingSpeed?: number;
    colliders?: Area[];
    dom?: DomNode;
}
export default class GameNode extends SkyNode {
    parent: GameNode | undefined;
    protected children: GameNode[];
    delays: Delay[];
    intervals: Interval[];
    private colliders;
    private _x;
    private _y;
    private _centerX;
    private _centerY;
    private _scaleX;
    private _scaleY;
    private _angle;
    worldX: number;
    worldY: number;
    drawingX: number;
    drawingY: number;
    worldScaleX: number;
    worldScaleY: number;
    worldRadian: number;
    worldSin: number;
    worldCos: number;
    private pixiContainer;
    set x(x: number);
    get x(): number;
    set y(y: number);
    get y(): number;
    set scaleX(scaleX: number);
    get scaleX(): number;
    set scaleY(scaleY: number);
    get scaleY(): number;
    set centerX(centerX: number);
    get centerX(): number;
    set centerY(centerY: number);
    get centerY(): number;
    set angle(angle: number);
    get angle(): number;
    speedX: number;
    toX: number | undefined;
    speedY: number;
    toY: number | undefined;
    scalingSpeedX: number;
    toScaleX: number | undefined;
    scalingSpeedY: number;
    toScaleY: number | undefined;
    rotationSpeed: number;
    toAngle: number | undefined;
    fadingSpeed: number;
    toAlpha: number | undefined;
    accelX: number;
    minSpeedX: number | undefined;
    maxSpeedX: number | undefined;
    accelY: number;
    minSpeedY: number | undefined;
    maxSpeedY: number | undefined;
    scalingAccelX: number;
    minScalingSpeedX: number | undefined;
    maxScalingSpeedX: number | undefined;
    scalingAccelY: number;
    minScalingSpeedY: number | undefined;
    maxScalingSpeedY: number | undefined;
    rotationAccel: number;
    minRotationSpeed: number | undefined;
    maxRotationSpeed: number | undefined;
    fadingAccel: number;
    minFadingSpeed: number | undefined;
    maxFadingSpeed: number | undefined;
    constructor(options: GameNodeOptions);
    step(deltaTime: number): void;
    appendTo(node: GameNode, index?: number): this;
    delete(): void;
    onMeet(targets: GameNode[], callback: () => void): void;
    moveLeft(options: {
        speed: number;
        accel?: number;
        maxSpeed?: number;
        toX?: number;
    }, moveEndHandler?: () => void): void;
    stopLeft(accel?: number): void;
    moveRight(options: {
        speed: number;
        accel?: number;
        maxSpeed?: number;
        toX?: number;
    }, moveEndHandler?: () => void): void;
    stopRight(accel?: number): void;
    moveUp(options: {
        speed: number;
        accel?: number;
        maxSpeed?: number;
        toY?: number;
    }, moveEndHandler?: () => void): void;
    stopUp(accel?: number): void;
    moveDown(options: {
        speed: number;
        accel?: number;
        maxSpeed?: number;
        toY?: number;
    }, moveEndHandler?: () => void): void;
    stopDown(accel?: number): void;
}
//# sourceMappingURL=GameNode.d.ts.map